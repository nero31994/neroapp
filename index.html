<!DOCTYPE html>
   <h1>  </h1>
<html lang="en">

<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=auto">
    <title>NERO TV</title>
    <script async src="f0a6f.txt" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com/"></script>
    <script src="jwpsrv.js"></script>
    <script src="jwplayer.js"></script>
    <script src="channels.js"></script>
    
    <link href="all.min.css" rel="stylesheet">
   <body class="bg-black text-white min-h-screen flex flex-col">
   
</head> 
  
    <div class="mb-6 w-half max-w-2xl mx-auto">
        <select id="channelSelect" class="w-half p-1 bg-gray-800 text-white rounded">
          <option value="10">
   TAP HERE TO SELECT CHANNEL</option>
                <!-- Channel options will be populated dynamically -->
        </select>
  

    <main class="flex-grow p-4">
        <div class="w-full max-w-4xl mx-auto bg-black-800 rounded-lg shadow-lg overflow-show mb-4">
                       <div id="player"  <p style="background-image: url('https://i.gifer.com/B798.gif');" class="w-16:9 aspect-video rounded"></div>
        
        
    </main>

    <script>
        jwplayer.key = 'XSuP4qMl+9tK17QNb+4+th2Pm9AWgMO/cYH8CI0HGGr7bdjo';
        function loadStream(channelKey) {
            const channel = channels[channelKey];
            if (!channel) return;
            jwplayer("player").setup({
                file: channel.url,
                type: channel.type,
                drm: channel.type === 'mpd' ? {
                    clearkey: {
                        keyId: channel.keyId,
                        key: channel.key
                    }
                } : undefined,
                width: "absolute",
              aspectratio: "32:18", 
                autostart: true, 
               
            });
        }
        function positionChannelSelect() {
            const select = document.getElementById('channelSelect');
            Object.keys(channels).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = channels[key].name;
                select.appendChild(option);
            });
        }
        window.onload = function() {
            positionChannelSelect();
            
            const channelSelect = document.getElementById('channelSelect');
            channelSelect.addEventListener('change', function() {
                loadStream(this.value);
            });

            const menuToggle = document.getElementById('menuToggle');
            const closeMenu = document.getElementById('closeMenu');
            const slideMenu = document.getElementById('slideMenu');

            menuToggle.addEventListener('click', () => {
                slideMenu.classList.remove('translate-x-full');
            });

            closeMenu.addEventListener('click', () => {
                slideMenu.classList.add('translate-x-full');
            });
        };
    </script>
    <script>
       const NUMBER_OF_SNOWFLAKES = 100;
    const MAX_SNOWFLAKE_SIZE = 2;
    const MAX_SNOWFLAKE_SPEED = 1;
    const SNOWFLAKE_COLOUR = '#ddd';
    const snowflakes = [];
    const canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.style.pointerEvents = 'none';
    canvas.style.top = '0px';
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    const createSnowflake = () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      radius: Math.floor(Math.random() * MAX_SNOWFLAKE_SIZE) + 1,
      color: SNOWFLAKE_COLOUR,
      speed: Math.random() * MAX_SNOWFLAKE_SPEED + 1,
      sway: Math.random() - 0.5
    });

    const drawSnowflake = snowflake => {
      ctx.beginPath();
      ctx.arc(snowflake.x, snowflake.y, snowflake.radius, 0, Math.PI * 2);
      ctx.fillStyle = snowflake.color;
      ctx.fill();
      ctx.closePath();
    }

    const updateSnowflake = snowflake => {
      snowflake.y += snowflake.speed;
      snowflake.x += snowflake.sway;
      if (snowflake.y > canvas.height) {
        Object.assign(snowflake, createSnowflake());
      }
    }

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      snowflakes.forEach(snowflake => {
        updateSnowflake(snowflake);
        drawSnowflake(snowflake);
      });
      requestAnimationFrame(animate);
    }

    for (let i = 0; i < NUMBER_OF_SNOWFLAKES; i++) {
      snowflakes.push(createSnowflake());
    }

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    window.addEventListener('scroll', () => {
      canvas.style.top = `${window.scrollY}px`;
    });

    animate(); 
        (adsbygoogle = window.adsbygoogle || []).push({});
    
    </script>
</body>


</html>

